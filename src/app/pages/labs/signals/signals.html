<section class="ui-labs-header">
  <div class="top-row">
    <h1>Angular Signals</h1>
    <a class="back" routerLink="/labs">← Back to Labs</a>
  </div>

  <p class="sub">
    A small, isolated demonstration of Angular’s signal-based reactivity model.
  </p>
</section>

<section class="ui-wrap" aria-label="Signals lab">
  <article class="ui-panel">
    <header class="ui-panel-header">
      <h2>What it does</h2>
      <p>
        This lab uses a single <strong>signal</strong> as the source of truth, then derives values with
        <strong>computed()</strong> and records changes with a single <strong>effect()</strong>.
        It’s intentionally small so you can see what updates, when, and why.
      </p>
    </header>

    <div class="readout" aria-label="Core primitives used">
      <div class="ui-readout-pill">signal(): <strong>mutable state</strong></div>
      <div class="ui-readout-pill">computed(): <strong>derived values</strong></div>
      <div class="ui-readout-pill">effect(): <strong>side-effects</strong></div>
      <div class="ui-readout-pill">untracked(): <strong>avoid feedback loops</strong></div>
    </div>

    <p class="ui-muted">
      As the value changes, derived values update automatically because they depend on the signal.
      A single effect appends an entry to history. <span class="mono">untracked()</span> prevents the
      history write from becoming a dependency that retriggers the effect.
    </p>

    <div class="controls" role="group" aria-label="Signal controls">
      <label class="slider">
        <span class="slider-label">
          Value: <strong>{{ value() }}</strong>
        </span>

        <input
          #slider
          type="range"
          min="0"
          max="100"
          step="1"
          [value]="value()"
          (input)="setFromInput(slider.value)"
          aria-label="Signal value slider"
        />
      </label>

      <div class="buttons" role="group" aria-label="Quick adjustments">
        <button type="button" (click)="nudge(-10)">-10</button>
        <button type="button" (click)="nudge(-1)">-1</button>
        <button type="button" (click)="nudge(1)">+1</button>
        <button type="button" (click)="nudge(10)">+10</button>
        <button type="button" (click)="reset()">Reset</button>
      </div>
    </div>

    <div class="readout" aria-label="Derived values">
      <div class="ui-readout-pill">Label: <strong>{{ label() }}</strong></div>
      <div class="ui-readout-pill">Doubled: <strong>{{ doubled() }}</strong></div>
      <div class="ui-readout-pill">Squared: <strong>{{ squared() }}</strong></div>
    </div>

    <section class="history" aria-label="Change history">
      <h3>History (latest first)</h3>

      @if (history().length === 0) {
        <p class="ui-muted">Interact with the controls above to generate entries.</p>
      } @else {
        <ul>
          @for (h of history(); track $index) {
            <li>
              <span class="time">{{ h.at }}</span>
              <span class="mono">v={{ h.value }}</span>
              <span class="mono">2v={{ h.doubled }}</span>
              <span class="mono">v²={{ h.squared }}</span>
            </li>
          }
        </ul>
      }
    </section>

    <div class="ui-notes">
      <h3>What it’s meant to teach</h3>
      <ul>
        <li><strong>Source of truth:</strong> one signal drives everything else.</li>
        <li><strong>Derived state:</strong> computed values update automatically from dependencies.</li>
        <li><strong>Side-effects:</strong> effects run in response to state changes (and should be kept small).</li>
        <li><strong>Tracking:</strong> use <span class="mono">untracked()</span> when recording state to avoid accidental dependency cycles.</li>
      </ul>
    </div>
  </article>
</section>
